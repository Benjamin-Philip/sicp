#+title: Exercise 1.11
#+date: 2025-07-28
#+weight: 111
#+PROPERTY: header-args:scheme :session *Scheme*
* The Question
A function \(f\) is defined by the rule that

\[f(n) =
\begin{cases} n & \text{if n < 3} \\
f(n - 1) + 2f(n - 2) + 3f(n - 3) & \text{if n} \ge 3 \\
\end{cases}\]

Write a procedure that computes \(f\) by means of a recursive process. Write a
procedure that computes \(f\) by means of an iterative process.
* The Answer
** Recursive Implementation
The rule directly spells out our recursive implementation:

#+begin_src scheme :results silent
(define (f n)
  (if (< n 3)
      n
      (+ (f (- n 1))
         (* 2 (f (- n 2)))
         (* 3 (f (- n 3))))))
#+end_src

Testing it out:

#+begin_src scheme
(f 2)
#+end_src

#+RESULTS:
: 2


#+begin_src scheme
(f 3)
#+end_src

#+RESULTS:
: 4


#+begin_src scheme
(f 10)
#+end_src

#+RESULTS:
: 1892
** Iterative Implementation
To implement \(f(n)\) iteratively, we can use the same principle as ~fib-iter~ and
pass \(f(n - 1)\), \(f(n - 2)\) and \(f(n - 3)\) as parameters and transform
them in each iteration, working upwards to \(n\) from \(3\).

we use the integers \(a\), \(b\) and \(c\) to represent \(f(n - 1)\), \(f(n -
2)\) and \(f(n - 3)\), and initialize them as \(f(2) = 2\), \(f(1) = 1\) and
\(f(0) = 0\). We then apply the following transformations successively:

\[\begin{align*}
a &\leftarrow a + 2b + 3c \\
b &\leftarrow a \\
c &\leftarrow b \\
\end{align*}\]

This gives us the following iterative process:

#+begin_src scheme :results silent
(define (f n)
  (define (iter a b c counter)
    (if (> counter n)
        a
        (iter (+ a (* 2 b) (* 3 c)) a b (+ counter 1))))
  (if (< n 3)
      n
      (iter 2 1 0 3)))
#+end_src

Testing it out, we get the same results:

#+begin_src scheme
(f 2)
#+end_src

#+RESULTS:
: 2


#+begin_src scheme
(f 3)
#+end_src

#+RESULTS:
: 4


#+begin_src scheme
(f 10)
#+end_src

#+RESULTS:
: 1892
